1. 인덱싱 한다.
	- 새로운 int 배열 만들어주고
	- 최댓값 찾아준다음
	- 새로운 배열의 최댓값 인덱스에 인덱싱한 값 넣어주고
	- 기존 배열의 최댓값은 int min - 1의 값을 넣어줌
	- 반복

2. 인덱싱된 int배열로 스택을 쌓아준다.
	- push_top을 통해 a_stack에 첨부터 끝까지 넣어주면 될듯

3. pivot을 두개 설정해준다.
	- 만약 100개의 값이 들어온다면 1/3 -> 33, 2/3 -> 66지점을 pivot으로 설정
	- 66보다 낮다면 b스택으로 옮겨줌
	- b스택에서 33보다 낮다면 rb해줌

4. 3번을 완료하면 3개의 그룹으로 나뉘게 된다.
	- a에 남아있는 그룹도 3개만 제외하고 모두 넘겨준다.

5. a에 3개 남은걸로 하드코딩해서 정렬시켜준다.

6. 이제 여기서부터 그리디 사용
	- b스택을 첨부터 끝까지 반복문 써서 a스택에 어디로 들어갈지 계산해주는것
	
	- b스택에서 한 노드가 a스택으로 들어가기 위해서는 3가지의 경우의 수가 있다.
		- 노드가 스택 a의 최소값보다 작을 경우
		- 노드가 스택 a의 최댓값보다 클 경우
		- 노드가 중간에 위치할 경우

	- a스택을 몇번 회전(ra)시켜야할지, b스택을 몇번 회전(rb)시켜야 할지 계산해준다.
		- b스택의 경우 노드를 맨 위로 올리기 위한 rb의 수를 구해주고
		- a스택의 경우 노드가 어떤 위치에 있어야하는지 인덱스를 계산해서 인덱스만큼 ra를 해주기 위해 계산해준다.
		- 결국 ra + rb가 최소가 되는 친구를 넘겨주면 된다.

7. 일단 오늘 여기까지 하면 진짜 너무 잘한거
ㅅㄱ
